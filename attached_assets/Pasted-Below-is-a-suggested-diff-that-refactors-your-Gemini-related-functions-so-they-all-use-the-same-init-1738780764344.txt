Below is a suggested diff that refactors your Gemini-related functions so they all use the same initialization logic via a common function (i.e. Option B). This change removes the duplicate code path by replacing individual calls to `initializeGemini` with a unified helper named `getGeminiClient`, which returns the Gemini client configuration (with the API key and endpoint). This refactor ensures that both the initial analysis flow (in `generateSmartListing`) and later steps (like in `analyzeBatchProducts` and `analyzeProduct`) work consistently.

Please review the following diff and verify it against your code before committing.

---

```diff:gemini.ts
// Add a new common helper for Gemini initialization
+function getGeminiClient() {
+  if (!process.env.GEMINI_API_KEY) {
+    throw new Error("GEMINI_API_KEY environment variable is not set. Please make sure it's properly configured.");
+  }
+  return {
+    apiKey: process.env.GEMINI_API_KEY,
+    endpoint: process.env.GEMINI_ENDPOINT || "https://default.gemini.endpoint/api",
+  };
+}

@@ Begin update in generateSmartListing
-async function generateSmartListing(files: File[]): Promise<GeminiAnalysis> {
-  // ... image processing code ...
-  // previously: no common initialization used
-  const response = await fetch(someLegacyUrl, { method: 'POST', body: formData });
-  // parse response
-}
+async function generateSmartListing(files: File[]): Promise<GeminiAnalysis> {
+  const geminiClient = getGeminiClient();
+  // ... image processing code to build formData ...
+  const response = await fetch(`${geminiClient.endpoint}/analyze-images`, {
+    method: 'POST',
+    headers: {
+      'Authorization': `Bearer ${geminiClient.apiKey}`,
+      // Ensure the headers match your backend requirements
+      'Content-Type': 'multipart/form-data'
+    },
+    body: formData,
+  });
+  // parse and return analysis result
+}
@@ Update analyzeBatchProducts for consistent Gemini access
-async function analyzeBatchProducts(products: Product[]): Promise<BatchAnalysisResult[]> {
-  // separate initialization call
-  initializeGemini();
-  // process analysis for batch products
-}
+async function analyzeBatchProducts(products: Product[]): Promise<BatchAnalysisResult[]> {
+  const geminiClient = getGeminiClient();
+  // process each product using geminiClient settings
+  // For example, loop over products and call:
+  // await fetch(`${geminiClient.endpoint}/analyze-product`, { ... });
+  // then return a consolidated BatchAnalysisResult array.
+}
@@ Update analyzeProduct for consistent Gemini access
-async function analyzeProduct(product: Product): Promise<GeminiAnalysis> {
-  // initialize separately
-  initializeGemini();
-  // process single product using legacy endpoint
-}
+async function analyzeProduct(product: Product): Promise<GeminiAnalysis> {
+  const geminiClient = getGeminiClient();
+  // perform analysis using the common client configuration
+  const response = await fetch(`${geminiClient.endpoint}/analyze-product`, {
+    method: 'POST',
+    headers: {
+      'Authorization': `Bearer ${geminiClient.apiKey}`,
+      'Content-Type': 'application/json'
+    },
+    body: JSON.stringify({ product }),
+  });
+  // Parse and return the analysis result
+}
```

---

### Explanation

1. **Common Initialization Function (`getGeminiClient`):**
   - This new function checks for the presence of `GEMINI_API_KEY` and sets up the Gemini client configuration (including a default endpoint if none is provided).
   - All Gemini-related functions now call `getGeminiClient()` to obtain the same configuration before making any API calls.

2. **Refactoring Endpoints:**
   - In `generateSmartListing`, instead of hitting a legacy URL directly, we now use the endpoint from the Gemini client.
   - Similarly, in both `analyzeBatchProducts` and `analyzeProduct`, the previous separate initialization (`initializeGemini`) is removed in favor of retrieving the Gemini client via `getGeminiClient()`.

3. **Consistent API Call Patterns:**
   - Every API call now includes a header with the API key (i.e. via `Authorization: Bearer ...`), ensuring that both the initial and subsequent calls use the same authentication and endpoint logic.

This unified approach should make the behavior consistent across the different phases of your Gemini analysis workflow while enforcing the use of `GEMINI_API_KEY` uniformly. Please review this diff carefully and let me know if you have any questions or need further adjustments before proceeding with a commit.

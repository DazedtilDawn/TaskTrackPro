Okay, let's break down the flow of the Smart Listing feature, focusing on image upload, AI analysis, eBay integration, and the interaction between components.

**1. Image Upload and Initial AI Analysis**

*   **Trigger:** The user initiates the flow by uploading images within the `AddProductModal` component, specifically using the `ImageUpload` component.
*   **`ImageUpload` Component:**
    *   When the user selects images, the `handleImagesUploaded` callback in `ImageUpload` is triggered.
    *   This callback, in turn, calls the `onImagesUploaded` prop, which is a function passed down from `AddProductModal`.
    *   The `ImageUpload` component will also store the uploaded image files in its own state.
*   **`AddProductModal` Component:**
    *   The `handleImagesUploaded` function inside `AddProductModal` receives the array of uploaded files.
    *   It sets a local state variable `uploadedFiles` with these files.
    *   Then it sets `showSmartListing` to `true` to display the `SmartListingModal`.

**2. Gemini AI Initial Analysis (Inside `SmartListingModal`)**

*   **`SmartListingModal` Opens:** When `showSmartListing` becomes `true`, the `SmartListingModal` component is rendered.
*   **`handleAnalyze` is Triggered:** The `SmartListingModal` has a `useEffect` that triggers `handleAnalyze` when the modal is open and `initialFiles` (passed from `AddProductModal`) are available.
*   **Gemini Client Initialization:** Inside `handleAnalyze`, a `GeminiClient` instance is created (if it doesn't already exist) using the API key and endpoint from environment variables.
*   **Prompt Construction:** The `handleAnalyze` function creates a prompt for the Gemini API. This prompt instructs the AI to:
    *   Analyze the uploaded images.
    *   Provide product title suggestions, a detailed description, and category recommendations.
    *   Suggest a recommended buy price and sell price.
    *   Provide any relevant market insights based on the image content.
    *   Return the response as a JSON object with specific fields.
*   **API Call:** The code then calls the Gemini API's `generateSmartListing` function (within the `GeminiClient`), passing in the prompt and the base64-encoded images.
*   **Response Handling:**
    *   If the API call is successful, the response is parsed, and the `analysis` state variable is updated with the AI-generated data.
    *   If there's an error, the `error` state is updated.
    *   If it is a retryable error the `useRetry` hook will retry up to the max retries allowed.

**3. Option to Refine with eBay Data**

*   **Display Initial AI Results:** The `SmartListingModal` displays the initial AI-generated title, description, category, and price recommendations to the user.
*   **Fetch eBay Data (Optional):** The `SmartListingModal` will have an option (e.g., a button or a toggle) to "Refine with eBay Data." When the user triggers this action, the following happens:
    *   The `fetchEbayData` function inside `SmartListingModal` is called, passing in the `title` generated by the AI as a search query.
    *   `fetchEbayData` calls the `ebayAuth.getAccessToken` function to get a valid access token
    *   `fetchEbayData` then makes a `POST` request to your server's `/ebayProxy` endpoint. This is done to avoid CORS issues and to keep your eBay API credentials secure on the server-side.
    *   The `/ebayProxy` endpoint (implemented as a Netlify function) forwards the request to the eBay API's `item_summary/search` endpoint, using the provided title as the search query (`q` parameter). It also sets appropriate headers for authentication and content type.
    *   The eBay API returns a list of active listings matching the search query.
    *   The `/ebayProxy` function then makes another `POST` request to `/ebayProxy` to retrieve recently sold items, using the same search query and the `filter` parameter set to `soldItems`.
    *   The `/ebayProxy` function then parses the JSON responses from both API calls.
    *   It then calculates:
        *   `minPrice`: Minimum price of active listings.
        *   `maxPrice`: Maximum price of active listings.
        *   `averagePrice`: Average price of active listings.
        *   `soldItemsAvg`: Average price of sold items (if available).
    *   It updates the `ebayData` and `ebayPriceRange` states in `SmartListingModal`.
    *   **Error Handling:** If any errors occur during the API calls, an error message is set in the `error` state.
*   **Display eBay Data:** The `SmartListingModal` displays the fetched eBay data to the user, including:
    *   Price range summary (min, max, average) of active listings.
    *   Average price of sold items (if available).
    *   A list of similar active listings with their prices.
    *   A price trend chart if you have enough historical data.

**4. Final AI Analysis (Optional)**

*   **User Confirmation:** The user reviews the initial AI suggestions and the eBay data. They can manually adjust the fields if needed.
*   **Send Data Back to AI:** The user clicks a button (e.g., "Refine Analysis") to trigger a second call to the Gemini API.
*   **Construct Final Prompt:** A new prompt is created that includes:
    *   The original prompt.
    *   The initial AI-generated suggestions (title, description, etc.).
    *   The fetched eBay data (price ranges, sold item prices, etc.).
*   **API Call:** The `GeminiClient` is used to send the updated prompt and data to the Gemini API.
*   **Response Handling:** The AI processes the combined information and returns a refined set of listing suggestions, potentially adjusting the title, description, and especially the recommended buy and sell prices based on the eBay market data.
*   **Display Final Results:** The `SmartListingModal` displays the final AI-generated listing details.
*   **User Confirmation:** The user can review the final suggestions and either accept them or make further manual edits.
*   **Submit:** When the user is satisfied, they click "Submit" or "Add to Inventory" (or "Add to Watchlist") in the `AddProductModal`. The `onSubmit` callback (passed from `AddProductModal`) is invoked, and the product data (including the final AI-generated fields) is sent to your backend for storage in Supabase.

**In essence, the flow is:**

1. **User uploads images** -> Triggers initial AI analysis (Gemini).
2. **AI provides initial suggestions** -> Displayed to the user.
3. **User optionally requests eBay data** -> Fetch data from eBay via proxy.
4. **Display eBay data** -> User can review and manually adjust.
5. **User confirms refinement** -> Send combined data (original prompt, AI suggestions, eBay data) back to AI.
6. **AI provides final analysis** -> Displayed to the user.
7. **User submits the form** -> Data is saved to the database.

This flow ensures that the user benefits from both the AI's creative capabilities and real-world market data from eBay, resulting in a more informed and potentially more profitable listing.

**Code Example: Triggering AI and eBay Data Fetch**

Here's how the `SmartListingModal` might trigger the AI analysis and eBay data fetch (based on the provided code):

```tsx
// Inside SmartListingModal.tsx

const handleAnalyze = useCallback(async () => {
  try {
    setLoading(true);
    setError(null);

    // 1. Initial AI Analysis (using GeminiClient)
    const result = await geminiClient.current!.generateSmartListing(files);
    setAnalysis(result);

    // 2. Fetch eBay Data (if user chooses to refine)
    if (result.title) {
      await fetchEbayData(result.title);
    }

  } catch (err) {
    console.error('Analysis error:', err);
    setError(err instanceof Error ? err.message : 'Failed to analyze');
  } finally {
    setLoading(false);
  }
}, [files, fetchEbayData]);

// ...

// Example of how to trigger the eBay data fetch
const handleRefineWithEbay = async () => {
  if (analysis && analysis.title) {
    await fetchEbayData(analysis.title);
  }
};

// ... in the return JSX ...
{
  analysis && (
    <button onClick={handleRefineWithEbay} disabled={loadingEbay}>
      {loadingEbay ? 'Fetching eBay Data...' : 'Refine with eBay Data'}
    </button>
  );
}
```

This is a simplified illustration. You'll need to adapt it to your specific component structure and state management, but it demonstrates the general idea. I hope this detailed explanation helps!
